---
title: "Waterbody Connectivity across Watersheds + Whirling Disease Susceptible Species"
author: "Chris Madsen"
date: "`r Sys.Date()`"
output: html_document
---

This document assesses the connectivity and flow direction of streams and rivers that flow from the watershed 08N to the target watersheds 08P, 08M, 08L and 08K. It also visualizes a layer of Whirling Disease susceptible species (mostly salmonids).

## Results

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = F, warning = F, fig.width = 10, fig.height = 6)
library(tidyverse)
library(sf)
library(leaflet)
library(DT)
library(terra)
library(bcdata)
library(patchwork)
library(ggraph)
```

### Study Area

```{r load_data}
# BC boundary polygon
bc = bcmaps::bc_bound() |> dplyr::summarise()

# Whirling Disease sensitive Species
if(!file.exists('data/whirling_disease_susceptible_species_occ_data.rds') & !file.exists('../data/whirling_disease_susceptible_species_occ_data.rds')){
  source("pull_whirling_disease_susceptible_species_records.R")
}

# if(file.exists("data/whirling_disease_susceptible_species_occ_data.rds")){
#   wd_sus = readRDS("data/whirling_disease_susceptible_species_occ_data.rds")
# } else {
#   wd_sus = readRDS("../data/whirling_disease_susceptible_species_occ_data.rds")
# }
if(file.exists("output/whirling_disease_susceptible_species_distribution_rasters.rds")){
  wd_sus = readRDS("output/whirling_disease_susceptible_species_distribution_rasters.rds")
} else {
  wd_sus = readRDS("../output/whirling_disease_susceptible_species_distribution_rasters.rds")
}

# Watershed drainages
wscd = bcmaps::wsc_drainages()

# Waterbodies with visitation by boats from Invasive Mussel Defence Program inspection data.
vis = sf::read_sf("C:/Users/CMADSEN/OneDrive - Government of BC/data/CNF/Waterbodies_with_binned_and_original_values.gpkg")

# Merge by SUB_DRAINAGE_AREA_CD
wscd_s = wscd |> 
  sf::st_zm() |> 
  dplyr::group_by(SUB_DRAINAGE_AREA_CD) |> 
  dplyr::summarise()

# Target watershed codes.
wscd_t = wscd_s |> 
  dplyr::filter(SUB_DRAINAGE_AREA_CD %in% c("08N","08P","08M","08L","08K"))

# Trim to BC
wscd_t = sf::st_intersection(wscd_t, bc)

wscd_t = wscd_t |> 
  dplyr::left_join(dplyr::distinct(dplyr::select(sf::st_drop_geometry(wscd),SUB_DRAINAGE_AREA_CD, SUB_DRAINAGE_AREA_NAME)))

em_lake = bcdc_query_geodata('freshwater-atlas-lakes') |> 
  filter(GNIS_NAME_1 == 'Emerald Lake') |> 
  filter(WATERSHED_GROUP_ID == 79) |> 
  collect() |> 
  sf::st_zm()

em_lake_c = em_lake |> 
  sf::st_centroid()
  
base_wd_map = ggplot() + 
  geom_sf(data = wscd_t, aes(fill = SUB_DRAINAGE_AREA_NAME)) + 
  geom_sf_text(data = wscd_t, aes(label = SUB_DRAINAGE_AREA_CD)) +
  geom_sf(data = em_lake_c, color = 'red') +
  ggrepel::geom_label_repel(
    data = em_lake,
    label = 'WD Detection in \nYoho National Park',
    aes(geometry = geometry),
    stat = "sf_coordinates",
    min.segment.length = 0,
    nudge_y = 100000,
    nudge_x = 50000
  ) +
  labs(fill = 'Watershed Name', title = 'Major Watersheds in SE British Columbia') +
  ggthemes::theme_map() + 
  ggspatial::annotation_scale(location = 'br')

inset = ggplot() + 
  geom_sf(data = bc) + 
  # geom_sf(data = sf::st_as_sfc(sf::st_bbox(wscd_t)),
  #         color = 'red', fill = 'transparent') +
  geom_sf(data = wscd_t |> dplyr::summarise(),
          color = 'red', fill = 'transparent') +
  ggthemes::theme_map() + 
  theme(panel.background = element_rect(color = 'black'))

base_wd_map + 
  inset_element(inset, left = 0.75, bottom = 0.75, right = 1, top = 1, align_to = 'full')
```

```{r border_of_08N_and_target_watersheds}

### Border of 08N that Touches Target Watersheds
if(interactive()) ggplot() + geom_sf(data = wscd_t)

border_08N_all = wscd_t |> 
  dplyr::filter(SUB_DRAINAGE_AREA_CD == '08N') |> 
  st_cast("LINESTRING")

if(interactive()) ggplot() + geom_sf(data = wscd_t) + geom_sf(data = border_08N_all, col = 'red')

border_08N = border_08N_all |> 
  sf::st_intersection(wscd_t[wscd_t$SUB_DRAINAGE_AREA_CD != '08N',]) |> 
  dplyr::summarise()

if(interactive()) ggplot() + geom_sf(data = wscd_t) + geom_sf(data = border_08N, col = 'red')

# Simplify geometry
# border_08N_s = rmapshaper::ms_simplify(border_08N)

border_08N_b = border_08N |> 
  sf::st_buffer(dist = 100)

```

<!-- ### Streams Along Border of 08N that Touch Target Watersheds -->

<!-- Note: these streams are quite hard to see - look for tiny red lines along the border of 08N with the other watersheds. -->

<!-- Note: these streams are quite hard to see - look for tiny red lines along the border of 08N with the other watersheds. -->

```{r find_streams_near_border_of_08N}
# Use the un-summarized version of the watersheds. Find the ones that 
# touch our border. Query BCDC one-by-one.
wscd_touch = wscd |> 
  sf::st_filter(border_08N_b) |> 
  sf::st_intersection(bc)

if(interactive()) ggplot() + geom_sf(data = wscd_t) + geom_sf(data = wscd_touch, fill = 'purple') + geom_sf(data = border_08N_all, col = 'red')

# Combine the 5 watersheds of interest
wscd_all = dplyr::summarise(wscd_t)

# Cycle through the smaller watershed drainage areas that touch the border with
# 08N; get all streams that touch that portion of the border; simplify the 
# resulting tables.
if(!file.exists('data/pascale/streams_along_08N_border.gpkg') & !file.exists('../data/pascale/streams_along_08N_border.gpkg')){
  streams_along_08N_border = wscd_touch$SUB_SUB_DRAINAGE_AREA_CD |> 
    purrr::map( ~ {
      
      print(.x)
      
      this_wscd = wscd_touch[wscd_touch$SUB_SUB_DRAINAGE_AREA_CD == .x,]
      border_touching_this_wscd = sf::st_intersection(border_08N_b, this_wscd)
      
      # The first query here is quite fragmentary: it only shows the piece of 
      # each stream that touches the boundary; I'd like to get the entire stream geometry.
      streams_touching_border = bcdc_query_geodata('freshwater-atlas-stream-network') |> 
        filter(STREAM_ORDER >= 3) |> 
        filter(INTERSECTS(border_touching_this_wscd)) |> 
        collect() |> 
        sf::st_zm()
      
      if(nrow(streams_touching_border) > 0){
        # If the sub-watershed is still too large to spatially filter streams,
        # filter the results here.
        print(paste0('pre-spatial filter # of streams:', nrow(streams_touching_border)))
        streams_touching_border = streams_touching_border |> 
          sf::st_filter(border_touching_this_wscd)
        print(paste0('post-spatial filter # of streams:', nrow(streams_touching_border)))
        
        # Simplify the results table.
        streams_touching_border = streams_touching_border |> 
          dplyr::select(GNIS_NAME, FWA_WATERSHED_CODE, WATERSHED_GROUP_ID, BLUE_LINE_KEY) |> 
          dplyr::mutate(across(-geometry, as.character)) |> 
          dplyr::mutate(wscd_name = .x)
      } else {
        streams_touching_border = NULL
      }
      return(streams_touching_border)
    })
  
  str_on_b = streams_along_08N_border |> 
    dplyr::bind_rows()
  
  if(stringr::str_detect(getwd(), 'scripts')){
    sf::write_sf(str_on_b, paste0('../data/pascale/streams_along_08N_border.gpkg'))
  } else {
    sf::write_sf(str_on_b, paste0('data/pascale/streams_along_08N_border.gpkg'))
  }
} else {
  if(file.exists('data/pascale/streams_along_08N_border.gpkg')) str_on_b = sf::read_sf('data/pascale/streams_along_08N_border.gpkg')
  if(file.exists('../data/pascale/streams_along_08N_border.gpkg')) str_on_b = sf::read_sf('../data/pascale/streams_along_08N_border.gpkg')
}

# base_wd_map + 
#   geom_sf(data = str_on_b, col = 'red')
```

### Connectivity Analysis:

#### Which Streams and Rivers Are Physically Connected?

The data source for streams and rivers in British Columbia is the open-access 'Freshwater Atlas', in particular the [Freshwater Atlas Stream Network](https://catalogue.data.gov.bc.ca/dataset/freshwater-atlas-stream-network) layer. A key field in this layer that describes flow direction and connectivity is the 'FWA_WATERSHED_CODE', which looks like this:

```{r}
str_on_b[1,]$FWA_WATERSHED_CODE
```

Each chunk of digits describes a particular waterbody (e.g. a stream or a river). In this example, '300' refers to the Columbia River. The following six digits (826265) describe some stream (e.g. 'Stream A'); this number tells us that Stream A flows into the Columbia River 82.6% along the course of the Columbia River. One level upstream of Stream A, we have Stream B, which flows into Stream A 38.2% along the course of Stream A. After Stream B, there are no more non-0 chunks of six digits, so we can be sure that Stream B is the identity of this stream.

For another work project, in an attempt to facilitate working with the massive dataset that is the Freshwater Atlas Stream Network, I have summarised the entire network to a 2-column table; column one describes the FWA_WATERSHED_CODE of the 'upstream' streams and column two describes of the 'downstream' streams. With this table, it is possible to abstract the stream network to a web of connected (and disconnected) nodes and links, in other words, a network or a graph. Finding connections in such a graph is lightning-fast in R, unlike attempting to spatially identify networks.

Here is a visual representation of the above process. Let's take a look at the stream whose FWA_WATERSHED_CODE is above.

### Network Connectivity Demo {.tabset}

#### Target Stream

```{r connectivity_demo_part_1}
eg_fwa = str_on_b[1,]$FWA_WATERSHED_CODE

eg_str = bcdata::bcdc_query_geodata('freshwater-atlas-stream-network') |> 
  bcdata::filter(FWA_WATERSHED_CODE == eg_fwa) |>
  bcdata::collect() |> 
  sf::st_zm() |>
  dplyr::group_by(FWA_WATERSHED_CODE, BLUE_LINE_KEY) |>
  dplyr::summarise() |> 
  dplyr::ungroup()

ggplot() + 
  geom_sf(data = eg_str) + 
  ggthemes::theme_map() + 
  ggspatial::annotation_scale(location = 'br') + 
  labs(title = paste0("FWA_WATERSHED_CODE: ",
                      stringr::str_replace(eg_str$FWA_WATERSHED_CODE,"000000.*","..., i.e. 'Stream B'"))
  )
```

#### Target Stream with Nearby Streams

```{r connectivity_demo_part_2}
# Buffer our example
eg_str_b = sf::st_buffer(eg_str, dist = 5000)

# Grab elevation too
eg_elev = terra::rast(elevatr::get_elev_raster(eg_str_b, z = 10))

# Trim elevation to example area
eg_elev = terra::crop(eg_elev, terra::project(terra::vect(eg_str_b), terra::crs(eg_elev)))

BLK = eg_str$BLUE_LINE_KEY

the_pattern = bcdata:::CQL(paste0("BLUE_LINE_KEY not like '",BLK,"'"))

# Get nearby streams.
eg_str_neighs = bcdata::bcdc_query_geodata('freshwater-atlas-stream-network') |> 
  bcdata::filter(bcdata::INTERSECTS(eg_str_b)) |>
  # bcdata::filter(the_pattern) |> 
  bcdata::collect() |> 
  dplyr::filter(FWA_WATERSHED_CODE != eg_str$FWA_WATERSHED_CODE)

# eg_str_bro = eg_str_neighs[eg_str_neighs$FWA_WATERSHED_CODE == "300-826265-000000-000000-000000-000000-000000-000000-000000-000000-000000-000000-000000-000000-000000-000000-000000-000000-000000-000000-000000",]

ggplot() + 
  geom_sf(data = eg_str, col = 'darkblue', linewidth = 1) + 
  # geom_sf(data = eg_str_bro, col = 'blue', linewidth = 0.8) +
  geom_sf(data = eg_str_neighs, col = 'lightblue') + 
  ggrepel::geom_text_repel(data = eg_str, 
                           aes(label = 'Stream B', geometry = geometry),
                           stat = 'sf_coordinates',
                           nudge_y = -200, nudge_x = -1400) + 
  ggthemes::theme_map() + 
  ggspatial::annotation_scale(location = 'br')
```

```{r get_connectivity}

# Get connectivity.
stream_conn = fwa.connect::stream_conn_tbl()

groups_for_streams = stream_conn |> 
  tidygraph::as_tbl_graph() |> 
  tidygraph::activate('nodes') |> 
  tidygraph::mutate(group_id = tidygraph::group_components()) |> 
  tidyr::as_tibble() |> 
  dplyr::rename(FWA_WATERSHED_CODE = name) |> 
  dplyr::filter(FWA_WATERSHED_CODE %in% c(eg_str$FWA_WATERSHED_CODE, eg_str_neighs$FWA_WATERSHED_CODE))
  
eg_str_neighs_g = eg_str_neighs |> 
  dplyr::left_join(groups_for_streams)

eg_str_g = eg_str |> 
  dplyr::left_join(groups_for_streams)
```

#### Connectivity Delineated and Abstraction Exemplified

```{r visually_explain_abstraction_to_tidygraph}
eg_tidy = stream_conn |> 
  tidygraph::as_tbl_graph() |> 
  tidygraph::activate('nodes') |> 
  tidygraph::mutate(group_id = tidygraph::group_components()) |> 
  # tidyr::as_tibble() |> 
  dplyr::filter(name %in% c(eg_str$FWA_WATERSHED_CODE, eg_str_neighs$FWA_WATERSHED_CODE))

abstract_g = ggraph(eg_tidy, layout = 'fr') + 
  # geom_edge_link(aes(color = as.character(group_id))) +
  geom_edge_link2(aes(color = as.character(node.group_id))) + 
  ggraph::geom_node_point(aes(color = as.character(group_id))) + 
  scale_colour_brewer(palette = 'Spectral') +
  scale_edge_color_brewer(palette = 'Spectral') +
  theme(plot.background = element_rect(fill = 'lightgrey', color = 'lightgrey'),
        legend.background = element_rect(fill = 'lightgrey')) + 
  labs(fill = "Elevation Contour Bin", color = 'Connected Group', edge_colour = 'Connected Group')
  
right_arrow_plot = ggplot() + 
  ggplot2::geom_path(aes(x = c(0,1), y = c(1,1)), linewidth = 2, arrow = grid::arrow()) + 
  geom_text(aes(x = 0.5, y = 1.1, label = "abstract...")) +
  scale_y_continuous(limits = c(0,2)) +
  ggthemes::theme_map() + 
  theme(plot.background = element_rect(fill = 'lightgrey', color = 'lightgrey'))

g = ggplot() + 
  tidyterra::geom_spatraster_contour_filled(data = eg_elev, alpha = 0.5) +
  geom_sf(data = eg_str_neighs_g, aes(col = as.character(group_id))) + 
  geom_sf(data = eg_str_g, aes(col = as.character(group_id))) + 
  scale_colour_brewer(palette = 'Spectral') +
  labs(color = 'Connected Group', fill = "Elevation \nContour \nBin (m)",
       title = "Streams with Elevation Map") + 
  theme(plot.background = element_rect(fill = 'lightgrey', color = 'lightgrey'),
        legend.background = element_rect(fill = 'lightgrey')) + 
  ggspatial::annotation_scale()

g + right_arrow_plot + abstract_g + 
  patchwork::plot_layout(widths = c(2,1,2))
```

Note that the present analysis does not (yet) include assessments of flow direction nor of obstacles to fish passage. Inclusion of such factors would theoretically reduce the number of stream/river connections that pose a risk for introduction of aquatic freshwater invasive species. Therefore, a simple analysis of physical connectivity between water bodies (streams, rivers, lakes) is potentially the most risk-averse.

### Interactive Plot with Stream Networks and Streams Touching Watershed Borders Marked

Note: Only hydrological networks with 100 or more streams are shown in this map, only streams in the Fraser and Columbia River Watersheds are displayed, and very small streams of stream order 1 and 2 are not shown on this map; however, the connectivity analysis included all streams / rivers / lakes in B.C.

Note: Watershed borders were buffered by 100 meters and any streams that intersected with this buffered layer were considered to touch the watershed border.

```{r assign_group_components_to_all_streams_in_analysis}
# Find group ID of the streams from above.
library(tidygraph)
all_streams_w_group_ids = tidygraph::as_tbl_graph(fwa.connect::stream_conn_tbl()) |> 
  activate(nodes) |> 
  mutate(group_id = group_components())

all_streams_w_group_ids <- as_tibble(all_streams_w_group_ids, what = "nodes") |> 
  dplyr::rename(FWA_WATERSHED_CODE = name)

str_on_b_g = str_on_b |> 
  dplyr::left_join(all_streams_w_group_ids)
```

```{r interactive_map_showing_watershed_border_crossing_streams_of_order_3_and_up}
# 
# leaflet() |> 
#   addTiles() |> 
#   addPolygons(
#     data = sf::st_transform(wscd_t, 4326),
#     label = ~SUB_DRAINAGE_AREA_CD,
#     fillColor = 'purple',
#     color = 'grey'
#   ) |> 
#   addPolylines(
#     data = sf::st_transform(str_on_b_g, 4326),
#     color = ~group_pal(group_id),
#     label = ~paste0('FWA code: ', stringr::str_remove_all(FWA_WATERSHED_CODE,"-000000.*"),
#                     '; Group ID: ',group_id),
#     group = 'rivers'
#   ) |> 
#   leaflet::addLayersControl(
#     overlayGroups = 'rivers'
#   ) |> 
#   addLegend(pal = group_pal, values = unique(str_on_b_g$group_id),
#             title = 'Group ID')
```

```{r split_watersheds_into_subwatersheds_and_then_download_all_streams}

# Split the watersheds into their subwatersheds, find intersection of those. Use those to download streams.
subws = wscd |> 
  dplyr::filter(SUB_DRAINAGE_AREA_CD %in% wscd_t$SUB_DRAINAGE_AREA_CD) |> 
  sf::st_intersection(bc)

# base_wd_map + 
#   geom_sf(data = subws, fill = 'transparent', col = 'grey')

# Try to download all streams in these watersheds. Maybe go by subwatershed so that it's not too large.
for(area_cd in unique(subws$SUB_SUB_DRAINAGE_AREA_CD)){
  
  if(!file.exists(paste0('../data/pascale/streams_in_target_watersheds/streams_',area_cd,'.gpkg')) & !file.exists(paste0('data/pascale/streams_in_target_watersheds/streams_',area_cd,'.gpkg'))){
    
    print(area_cd)
    
    the_subws = subws[subws$SUB_SUB_DRAINAGE_AREA_CD == area_cd,]
    
    ggplot() + geom_sf(data = the_subws)
    
    streams = bcdc_query_geodata('freshwater-atlas-stream-network') |> 
      bcdata::filter(INTERSECTS(the_subws)) |> 
      collect() |> 
      sf::st_zm() |> 
      dplyr::mutate(watershed_id = area_cd)
    
    # ggplot() + 
    #   geom_sf(data = the_subws, fill = 'purple', col = 'black') + geom_sf(data = streams, col='red')
    
    if(stringr::str_detect(getwd(), 'scripts')){
      sf::write_sf(streams, paste0('../data/pascale/streams_in_target_watersheds/streams_',area_cd,'.gpkg'))
    } else {
      sf::write_sf(streams, paste0('data/pascale/streams_in_target_watersheds/streams_',area_cd,'.gpkg'))
    }
  }
}
```

```{r read_in_and_join_all_streams_dropping_duplicate_geometries}

if(!file.exists('data/pascale/all_streams_in_watersheds_of_interest.gpkg') & !file.exists('../data/pascale/all_streams_in_watersheds_of_interest.gpkg')){

if(stringr::str_detect(getwd(), 'scripts')){
    stream_gpkgs = list.files('../data/pascale/streams_in_target_watersheds/',
               pattern = '.gpkg$',
               full.names = T) |> 
      lapply(sf::read_sf)
  } else {
    stream_gpkgs = list.files('data/pascale/streams_in_target_watersheds/',
               pattern = '.gpkg$',
               full.names = T) |> 
      lapply(sf::read_sf)
  }

# All streams in watersheds! Pick fewer columns and bind all rows.
all_str_in_ws = purrr::map(stream_gpkgs, ~ {
  .x |> 
    dplyr::select(GNIS_NAME, BLUE_LINE_KEY, FWA_WATERSHED_CODE, STREAM_ORDER) |> 
    dplyr::filter(STREAM_ORDER >= 3)
}) |> 
  dplyr::bind_rows()

# Add on graph component ids; drop components that aren't in the handful we identified as 
# border-crossing groups!
all_str_in_ws = all_str_in_ws |> 
  dplyr::left_join(all_streams_w_group_ids)

# Re-enumerate the group_ids, starting from 1
unique_group_levels = unique(all_str_in_ws[!is.na(all_str_in_ws$group_id),]$group_id)

group_corrector = data.frame(group_id = unique_group_levels[order(unique_group_levels)]) |> 
  dplyr::mutate(new_group_id = row_number())

all_str_in_ws = all_str_in_ws |> 
  dplyr::left_join(group_corrector) |> 
  dplyr::mutate(group_id = new_group_id) |> 
  dplyr::select(-new_group_id)

# dplyr::filter(group_id %in% unique(str_on_b_g$group_id))

if(stringr::str_detect(getwd(), 'scripts')){
  sf::write_sf(all_str_in_ws,'../data/pascale/all_streams_in_watersheds_of_interest.gpkg')
} else {
  sf::write_sf(all_str_in_ws,'data/pascale/all_streams_in_watersheds_of_interest.gpkg')
}
} else {
  if(stringr::str_detect(getwd(), 'scripts')){
    all_str_in_ws = sf::read_sf('../data/pascale/all_streams_in_watersheds_of_interest.gpkg')
  } else {
    all_str_in_ws = sf::read_sf('data/pascale/all_streams_in_watersheds_of_interest.gpkg')
  }
}

```

```{r summarise_streams_by_fwa_code_BLK_Name_and_group_id}
if(!file.exists('data/pascale/all_streams_in_watersheds_of_interest_summarized.gpkg') & !file.exists('../data/pascale/all_streams_in_watersheds_of_interest_summarized.gpkg')){
  
all_str_sum = all_str_in_ws |> 
  dplyr::group_by(GNIS_NAME, BLUE_LINE_KEY, FWA_WATERSHED_CODE,
                  STREAM_ORDER, group_id) |> 
  dplyr::summarise()

if(stringr::str_detect(getwd(), 'scripts')){
  sf::write_sf(all_str_sum,'../data/pascale/all_streams_in_watersheds_of_interest_summarized.gpkg')
} else {
  sf::write_sf(all_str_sum,'data/pascale/all_streams_in_watersheds_of_interest_summarized.gpkg')
}
} else {
  if(stringr::str_detect(getwd(), 'scripts')){
    all_str_sum = sf::read_sf('../data/pascale/all_streams_in_watersheds_of_interest_summarized.gpkg')
  } else {
    all_str_sum = sf::read_sf('data/pascale/all_streams_in_watersheds_of_interest_summarized.gpkg')
  }
}

if(!file.exists('data/pascale/all_streams_in_watersheds_of_interest_summarized_simple.gpkg') & !file.exists('../data/pascale/all_streams_in_watersheds_of_interest_summarized_simple.gpkg')){
# Try simplifying their geometry.
all_str_sum_s = rmapshaper::ms_simplify(all_str_sum)

if(stringr::str_detect(getwd(), 'scripts')){
  sf::write_sf(all_str_sum_s,'../data/pascale/all_streams_in_watersheds_of_interest_summarized_simple.gpkg')
} else {
  sf::write_sf(all_str_sum_s,'data/pascale/all_streams_in_watersheds_of_interest_summarized_simple.gpkg')
}
} else {
  if(stringr::str_detect(getwd(), 'scripts')){
    all_str_sum_s = sf::read_sf('../data/pascale/all_streams_in_watersheds_of_interest_summarized_simple.gpkg')
  } else {
    all_str_sum_s = sf::read_sf('data/pascale/all_streams_in_watersheds_of_interest_summarized_simple.gpkg')
  }
}

# Drop NA group?
all_str_sum_s = all_str_sum_s |> dplyr::filter(!is.na(group_id))
```

```{r find_downstream_of_Yoho_National_Park}
library(igraph)
library(tidygraph)
yoho = bcdc_query_geodata('national-parks-of-canada-within-british-columbia') |> 
  dplyr::filter(ENGLISH_NAME == "Yoho National Park of Canada") |>
  collect()

# ggplot() +
#   geom_sf(data = wscd_t) +
#   geom_sf(data = yoho, fill = 'purple')

# Streams in Yoho
yoho_str = sf::st_filter(all_str_sum_s, yoho)

# Streams that pass through Emerald Lake
em_str = sf::st_filter(all_str_sum_s, em_lake)

em_codes = unique(em_str$FWA_WATERSHED_CODE)

# ggplot() +
#   geom_sf(data = yoho, col = 'purple') +
#   geom_sf(data = em_lake, fill = 'blue') +
#   geom_sf(data = yoho_str)

# Graph of streams that includes Yoho streams
yoho_str_grp = all_str_sum_s |> dplyr::filter(group_id %in% c(unique(yoho_str$group_id)))

# All codes of streams in Yoho National Park
park_codes = unique(yoho_str$FWA_WATERSHED_CODE)

stream_conn_graph = stream_conn |> tidygraph::as_tbl_graph()
stream_conn_igraph = stream_conn |> tidygraph::as_tbl_graph() |> igraph::as.igraph()

all_ds_str = stream_conn_graph |> 
  activate(nodes) %>%
  filter(name %in% em_codes) %>%
  pull(name) %>%
  map(~ {
    dat = igraph::neighborhood(stream_conn_igraph, order = igraph::vcount(stream_conn_igraph), nodes = .x, mode = "out") |> 
      unlist() |> 
      as.data.frame()
    
    dat$FWA_WATERSHED_CODE = rownames(dat)
    dat = dplyr::select(dat, FWA_WATERSHED_CODE)
  }
  ) |> 
  dplyr::bind_rows() |> 
  dplyr::distinct()


library(data.table)

str_ds_of_em_lake = all_str_in_ws[all_str_in_ws$FWA_WATERSHED_CODE %chin% all_ds_str$FWA_WATERSHED_CODE,]

# Also find how many steps it takes to get to each of these neighbours.
start_index = which(V(stream_conn_igraph)$name %in% em_codes[2])

distance_matrix = stream_conn_igraph |> 
  igraph::distances(v = start_index, mode = "out")

dist_df = as.table(distance_matrix) |> 
  as.data.frame()

colnames(dist_df) <- c("from", "to", "distance")

downstream_distances <- dist_df %>%
  filter(distance > 0, distance != Inf) %>%
  arrange(from, distance)

# Add the null step (starting stream piece)
downstream_distances = downstream_distances |> 
  add_row(from = downstream_distances[1,1],
          to = downstream_distances[1,1],
          distance = 0) |> 
  dplyr::arrange(distance)

```

```{r make_animation_for_columbia_river_ws_spread}
# # Make animation for Columbia River watershed.
# 
# # Get Columbia River Watershed polygon.
# columbia = wscd_t |> dplyr::filter(SUB_DRAINAGE_AREA_CD == '08N')
# 
# # Hydroelectric dams in area.
# dams_in_col = bcdc_query_geodata('bc-dams') |> 
#   bcdata::filter(bcdata::INTERSECTS(columbia)) |> 
#   collect()
# 
# # Streams in area.
# str_in_col = all_str_in_ws |> 
#       sf::st_filter(columbia)
# 
# for(i in 1:nrow(downstream_distances)){
#   
#   fwa_codes_for_this_loop = downstream_distances |> 
#     dplyr::slice(1:i) |> 
#     pull(to)
# 
#   p = ggplot() + 
#     ggthemes::theme_map() +
#     ggspatial::annotation_scale() +
#     geom_sf(data = wscd_t, fill = 'grey') +
#     geom_sf_text(data = wscd_t, aes(label = SUB_DRAINAGE_AREA_CD)) +
#     geom_sf(
#       data = st_buffer(st_as_sfc(st_bbox(bcmaps::bc_bound())), dist = 1000000), 
#       col = 'transparent',
#       fill = 'grey', 
#       alpha = 0.5
#     ) +
#     geom_sf(data = columbia) +
#     geom_sf(data = yoho, col = 'purple') +
#     geom_sf(data = em_lake, fill = 'blue') + 
#     ggrepel::geom_text_repel(
#       data = em_lake, 
#       aes(geometry = geometry),
#       stat = 'sf_coordinates',
#       label = 'Emerald Lake',
#       nudge_x = 100000,
#       nudge_y = 10000) + 
#     # geom_sf(
#     #   data = str_in_col |> 
#     #     dplyr::filter(STREAM_ORDER >= 4),
#     #   col = 'darkblue',
#     #   alpha = 0.5
#     # ) +
#     geom_sf(data = str_ds_of_em_lake |> 
#               dplyr::filter(FWA_WATERSHED_CODE %in% fwa_codes_for_this_loop), col = 'red') + 
#     geom_sf(data = dams_in_col |> sf::st_buffer(500), fill = 'purple') +
#     coord_sf(xlim = sf::st_bbox(columbia)[c(1,3)],
#              ylim = sf::st_bbox(columbia)[c(2,4)]) +
#     labs(caption = paste0("Figure ",i," of ",nrow(downstream_distances)))
#   
#   ggsave(plot = p,
#     filename = paste0("output/emerald_lake_infection_gif/step_",i,".jpeg"),
#     width = 5, height = 5)
# }
# 
# images_for_gif = magick::image_read(list.files(path = 'output/emerald_lake_infection_gif',
#                                                pattern = 'jpeg$',
#            full.names = T))
# 
# magick::image_write_gif(image = images_for_gif,
#                         path = "output/emerald_lake_infection_gif/emerald_lake_infection.gif",
#                         delay = 1)
# 
# # Include streams that are upstream but no more than 4 degrees slope.
```

```{r interactive_plot_with_all_streams}

all_str_sum_s_wgs = sf::st_transform(all_str_sum_s, 4326)

# Number of streams in each group; keep only those with > 100
groups_to_keep = all_str_sum_s_wgs |> 
  sf::st_drop_geometry() |> 
  dplyr::count(group_id, sort = T) |> 
  dplyr::filter(n > 100) |> 
  dplyr::pull(group_id)

all_str_sum_s_wgs = all_str_sum_s_wgs |> dplyr::filter(group_id %in% groups_to_keep)

group_ids = unique(all_str_sum_s_wgs$group_id)

if(interactive()){
  
  ggplot() + 
    geom_sf(data = all_str_sum_s_wgs, aes(col = as.character(group_id))) + 
    scale_color_brewer(palette = 'Set2') +
    ggthemes::theme_map() + 
    theme(legend.position = 'none')
  
  ggsave(filename = 'data/pascale/stream_group_colour_still.png',
         width = 6, height = 6)
  
  base_r = terra::rast(nrows = 3000, ncols = 3000, 
                       xmin = st_bbox(all_str_sum_s_wgs)[1],
                       xmax = st_bbox(all_str_sum_s_wgs)[3],
                       ymin = st_bbox(all_str_sum_s_wgs)[2],
                       ymax = st_bbox(all_str_sum_s_wgs)[4])
  
  1:length(unique(all_str_sum_s_wgs$group_id)) |> 
    purrr::iwalk( ~ {
      print(.x)
      the_group_id = group_ids[[.x]]
      group_dat = all_str_sum_s_wgs[all_str_sum_s_wgs$group_id == the_group_id,] |> 
        terra::vect() |> 
        terra::rasterize(base_r)
      
      # Crop to bounding box of this group.
      # terra::plot(group_dat)
      
      cropper = terra::ext(terra::vect(all_str_sum_s_wgs[all_str_sum_s_wgs$group_id == the_group_id,]))
      
      # terra::plot(cropper, add = T)
      group_dat_c = terra::mask(terra::crop(group_dat, cropper), cropper)
      # terra::plot(group_dat_c)
      
      terra::writeRaster(group_dat_c, paste0('data/pascale/raster_group_',the_group_id,'.tif'), overwrite = TRUE)
    }, .progress = TRUE)
  
  # rast_1 = all_str_sum_s_wgs[all_str_sum_s_wgs$group_id == group_ids[1],] |> 
  #   terra::vect() |> 
  #   terra::rasterize(base_r)
  # 
  # rast_2 = all_str_sum_s_wgs[all_str_sum_s_wgs$group_id == group_ids[2],] |> 
  #   terra::vect() |> 
  #   terra::rasterize(base_r)
  # 
  # terra::writeRaster(rast_1, paste0('data/pascale/raster_group_',group_ids[1],'.tif'), overwrite = TRUE)
  # terra::writeRaster(rast_2, paste0('data/pascale/raster_group_',group_ids[2],'.tif'), overwrite = TRUE)

  }

if(interactive()){
  raster_groups = list.files(path = 'data/pascale/',
           pattern = 'raster_group_[0-9]+\\.tif',
           full.names = T) |> 
  lapply(terra::rast)
} else {
  raster_groups = list.files(path = '../data/pascale/',
           pattern = 'raster_group_[0-9]+\\.tif',
           full.names = T) |> 
  lapply(terra::rast)
}


# terra::rast(raster_groups)
# rast_gr_2 = terra::rast('../data/pascale/raster_group_2.tif')
# rast_gr_3 = terra::rast('../data/pascale/raster_group_3.tif')

# terra::plot(rast_gr_2)
group_pal = colorFactor(palette = 'Set1', domain = group_ids)

ws_cols = colorFactor(palette = 'Set1', domain = wscd_t$SUB_DRAINAGE_AREA_CD)

l = leaflet() |> 
  addTiles(group = 'streets') |> 
  addProviderTiles(providers$Esri.WorldTopoMap, group = 'topography') |> 
  addProviderTiles(providers$CartoDB, group = 'cartoDB') |> 
  addMapPane('polygon_pane', zIndex = 200) 
  
for(the_id in group_ids){
  i = which(unique(all_str_sum_s_wgs$group_id) == the_id)
  l = l |> 
    addMapPane(paste0('rast_gr_',the_id,'_pane'), zIndex = (300 + i*50))
}

# addMapPane('rast_gr_2_pane', zIndex = 300) |>
  # addMapPane('rast_gr_3_pane', zIndex = 400) |>
 l = l |> 
    addMapPane('border_crossing_streams', zIndex = 350 + length(group_ids)*50)
    
 # l |> 
 #   addRasterImage(
 #       raster::raster(raster_groups[[1]]),
 #       colors = RColorBrewer::brewer.pal(length(unique(all_str_sum_s_wgs$group_id)), "Set1")[1],
 #       opacity = 1,
 #       group = paste0('Group ',group_ids[1]),
 #       options = pathOptions(pane = paste0('rast_gr_',group_ids[1],'_pane'))
 #       # options = pathOptions(pane = 'rast_gr_1_pane'))
 #     )
 for(i in 1:length(group_ids)){
   
   the_group_id = group_ids[order(group_ids)][i]
   
   l = l |> 
     addRasterImage(
       raster::raster(raster_groups[[i]]),
       colors = RColorBrewer::brewer.pal(length(group_ids), "Set1")[i],
       opacity = 1,
       group = paste0('H. Network ',the_group_id),
       options = pathOptions(pane = paste0('rast_gr_',group_ids[i],'_pane'))
     )
 }

# addRasterImage(x = raster::raster(rast_gr_2),
#                    colors = RColorBrewer::brewer.pal(2, "Set1")[1],
#                    opacity = 1,
#                    group = 'Group 2',
#                    options = pathOptions(pane = 'rast_gr_2_pane')) |>
#   addRasterImage(x = raster::raster(rast_gr_3),
#                  colors = RColorBrewer::brewer.pal(2, "Set1")[3],
#                  opacity = 1,
#                  group = 'Group 3',
#                  options = pathOptions(pane = 'rast_gr_3_pane')) |>
 l |> 
  addPolygons(
    data = sf::st_transform(wscd_t, 4326),
    label = ~SUB_DRAINAGE_AREA_CD,
    fillColor = ~wscd_t$SUB_DRAINAGE_AREA_CD,
    color = 'grey',
    fillOpacity = 0,
    group = 'Watersheds',
    options = pathOptions(pane = 'polygon_pane')
  ) |>
  addCircleMarkers(
    data = sf::st_transform(sf::st_centroid(str_on_b_g), 4326),
    color = 'orange',
    fillColor = 'orange',
    fillOpacity = 0.65,
    radius = 3,
    group = 'Streams touching borders',
    options = pathOptions(pane = 'border_crossing_streams')
  ) |> 
  addPolylines(
    data = sf::st_transform(str_on_b_g, 4326),
    color = 'orange',
    label = ~paste0('FWA code: ', stringr::str_remove_all(FWA_WATERSHED_CODE,"-000000.*"),
                    '; Group ID: ',group_id),
    group = 'streams touching borders',
    options = pathOptions(pane = 'border_crossing_streams')
  ) |> 
  leaflet::addLayersControl(
    position = 'bottomright',
    baseGroups = c('cartoDB','topography','streets'),
    overlayGroups = c('Watersheds','Streams touching borders',
                      paste0('H. Network ',group_ids[order(group_ids)])),
    options = layersControlOptions(collapsed = FALSE)
  ) |> 
  addLegend(pal = group_pal, values = unique(all_str_sum_s_wgs$group_id),
            title = 'Hydrological Network ID') |> 
  addLegend(title = htmltools::HTML('Streams Touching <br>Watershed Borders'),
            colors = 'orange', labels = "Stream") |> 
  leaflet.extras::addResetMapButton()
```

```{r simulate_infection_of_emerald_lake}
# if(interactive()){
#   str_em_lake = all_str_sum_s_wgs |> 
#     sf::st_filter(em_lake |> sf::st_transform(4326)) |> 
#     dplyr::arrange(STREAM_ORDER) |> 
#     dplyr::slice(1)
#   
#   # Convert to tidygraph object
#   tg <- as_tbl_graph(stream_conn)
#   
#   specific_fwa <- tg |> 
#     dplyr::filter(name == str_em_lake$FWA_WATERSHED_CODE) |> 
#     dplyr::pull(name)
#   
#   # Function to find nodes within n steps
#   find_neighbors <- function(graph, node, steps) {
#     ig <- igraph::as.igraph(graph)
#     
#     neighbors <- igraph::make_ego_graph(ig, order = steps, nodes = node)[[1]] |>
#       as_tbl_graph() |> 
#       as_tibble() |> 
#       pull(name)
#     neighbors
#   }
#   
#   # Initialize a list to store the results
#   neighbor_list <- list()
#   
#   # Find neighbors within 1 step, 2 steps, 3 steps, etc.
#   for (steps in 1:10) {
#     
#     neighbor_nodes <- find_neighbors(tg, specific_fwa, steps-1)
#     neighbor_list[[steps]] <- neighbor_nodes
#     
#     g = ggplot() + 
#       geom_sf(data = wscd_t[wscd_t$SUB_DRAINAGE_AREA_CD == '08N',]) +
#       geom_sf(data = all_str_sum_s_wgs[all_str_sum_s_wgs$FWA_WATERSHED_CODE %in% (neighbor_list[[steps]]),],
#               col = 'red') + 
#       ggrepel::geom_text_repel(data = str_em_lake,
#                                aes(geometry = geom,
#                                    label = 'Emerald Lake'),
#                                stat = 'sf_coordinates',
#                                nudge_x = 100000,
#                                nudge_y = 30000) +
#       ggthemes::theme_map() + 
#       labs(title = paste0("Step ",steps))
#     
#     ggsave(filename = paste0(here::here(),"/output/emerald_lake_infection_gif/step_",steps,".jpeg"),
#            width = 3,
#            height = 3,
#            plot = g)
#   }
#   
#   magick::image_read(
#     paste0(here::here(),"/output/emerald_lake_infection_gif/step_",c(1:10),".jpeg")) |> 
#     image_write_gif(path = paste0(here::here(),"/output/emerald_lake_infection_gif/infection_gif.gif"),
#                     delay = 1)
# }
```

```{r make_and_show_gif, out.height=600, out.width=600}

### Animation of Potential Infection Spread {.tabset}

# This animation is somewhat exaggerated - each step includes the entirety of a waterbody. Sometimes this jump includes a very large distance. However, this animation may serve to illustrate just how connected waterbodies are within a watershed.

#### Animation


# magick::image_read(paste0(here::here(),"/output/emerald_lake_infection_gif/infection_gif.gif"))
# knitr::include_graphics(path = paste0(here::here(),"/output/emerald_lake_infection_gif/infection_gif.gif"))

#### Hide Animation
```

```{r}
ws = sf::read_sf("C:/Users/CMADSEN/Downloads/ColumbiaRiverWatershed.kml")

# Make subset layer of fishing lakes and salmon fishing lakes.
fishing_lakes = bcdc_query_geodata('freshwater-atlas-lakes') |> 
  filter(GNIS_NAME_1 %in% c("Sheridan Lake","Vedder Canal","Shuswap Lake")) |> 
  collect() |> 
  sf::st_zm() |> 
  dplyr::group_by(wb_name = GNIS_NAME_1) |> 
  dplyr::summarise() |> 
  sf::st_transform(4326)

fishing_rivers = bcdc_query_geodata('freshwater-atlas-stream-network') |> 
  filter(GNIS_NAME %in% c("Chilliwack River","Vedder River","Fraser River")) |> 
  collect() |> 
  sf::st_zm() |> 
  dplyr::group_by(wb_name = GNIS_NAME) |> 
  dplyr::summarise() |> 
  sf::st_transform(4326)

fishing_wbs = dplyr::bind_rows(
  fishing_lakes,
  fishing_rivers
)

salmon_fishing_rivers = bcdc_query_geodata('freshwater-atlas-stream-network') |> 
  filter(GNIS_NAME %in% c("Chilliwack River","Vedder River","Fraser River","Campbell River","Kitimat River")) |> 
  collect() |> 
  sf::st_zm() |> 
  dplyr::group_by(wb_name = GNIS_NAME) |> 
  dplyr::summarise() |> 
  sf::st_transform(4326)

# Clip the Fraser River.
fishing_wbs[fishing_wbs$wb_name == 'Fraser River',]$geometry = sf::st_intersection(
  fishing_wbs[fishing_wbs$wb_name == 'Fraser River',]$geometry,
  bcmaps::nr_regions()[str_detect(bcmaps::nr_regions()$ORG_UNIT_NAME,"South"),] |> 
    sf::st_transform(4326)
)

salmon_fishing_rivers[salmon_fishing_rivers$wb_name == 'Fraser River',]$geometry = sf::st_intersection(
  salmon_fishing_rivers[salmon_fishing_rivers$wb_name == 'Fraser River',]$geometry,
  bcmaps::nr_regions()[str_detect(bcmaps::nr_regions()$ORG_UNIT_NAME,"South"),] |> 
    sf::st_transform(4326)
)
```

```{r snag_key_highways}

road_test = bcdc_query_geodata('digital-road-atlas-dra-master-partially-attributed-roads') |> 
  filter(NUMBER_OF_LANES > 4) |> collect()

ws_albers = sf::st_transform(ws,3005)

major_highways = bcdc_query_geodata('digital-road-atlas-dra-master-partially-attributed-roads') |> 
  filter(!is.na(HIGHWAY_ROUTE_NUMBER)) |>
  filter(INTERSECTS(ws_albers)) |> 
  # filter(NUMBER_OF_LANES >= 4) |>
  collect() |> 
  sf::st_transform(4326)
```

```{r read_in_tubifex_raster_and_make_legend}
if(file.exists('output/Predicted_Ttubifex_density.tif')) {
  tub_prob_w_carbon = terra::rast('output/Predicted_Ttubifex_density.tif')
} else {
  tub_prob_w_carbon = terra::rast('../output/Predicted_Ttubifex_density.tif')
}

tub_w_c_as_df = as.data.frame(tub_prob_w_carbon, xy = TRUE)

names(tub_w_c_as_df)[3] <- 'tubifex_pred_density'

# Add in the result raster as a layer here too.
raster_pal = leaflet::colorNumeric('Reds',
                                   domain = unique(terra::values(tub_prob_w_carbon)),
                                   na.color = 'white')

raster_pal_legend = leaflet::colorNumeric(
  'Reds',
  reverse = T,
  domain = unique(terra::values(tub_prob_w_carbon)),
  na.color = 'white')

```

### Waterbody Visitation, **T. tubifex** predicted density, Major Highways, and Whirling Disease susceptible fish {.tabset}

Map details:

-   Invasive Mussel Defence Program inspection data span 2015 to present.

-   This map only includes inspections of boats coming from Whirling Disease-infected states or provinces/territories in the USA and Canada, respectively. The number of inspections from these infected areas may be artificially high, as ALL inspections from, e.g., Alberta are included, not only inspections from infected waterbodies within Alberta.

-   It also shows only those destination water bodies with 1000 or more inspections.

-   The list of Whirling Disease susceptible fish species was accessed from the provincial government website [here](https://www2.gov.bc.ca/gov/content/environment/plants-animals-ecosystems/fish/aquatic-species/aquatic-invasives/whirling-disease), under the header "*Lifecycle*". The occurrence data 

#### Map with listed layers

Note: roads are displayed in pink, and key fishing locations are presented in purple.

```{r imdp_destination_lakes}

em_lake = bcdata::bcdc_query_geodata('freshwater-atlas-lakes') |> 
  dplyr::filter(GNIS_NAME_1 == 'Emerald Lake',
                WATERSHED_GROUP_ID == 79) |> 
  bcdata::collect() |> 
  dplyr::select(WATERSH = WATERSHED_GROUP_ID,
                GNIS_NA = GNIS_NAME_1) |> 
  dplyr::mutate(TotalInspections = 73, Simple_Counter = 4, Complex_Counter = 0, Very_Complex_Counter = 1, Non_Motorized_Counter = 125)

dat = read_sf("W:/CMadsen/Projects/ZQMussels/data/Waterbodies_with_Inspection_Data_Summaries_all_years_WD_Infected_Areas.gpkg")

dat = dat |> sf::st_transform(4326)

# Add colours
my_pal = leaflet::colorBin(palette = 'Spectral',
                           domain = dat$TotalInspections,
                           reverse = T)

my_pal_l = leaflet::colorBin(palette = 'Spectral',
                           domain = dat$TotalInspections)

over_1000 = dat |> 
  dplyr::filter(!GNIS_NA %in% c("Pacific Ocean","Dry Storage")) |> 
  dplyr::filter(TotalInspections > 1000)

popup_tbls = leafpop::popupTable(
  over_1000 |> 
    sf::st_drop_geometry() |> 
    dplyr::select(WATERSH,GNIS_NA,TotalInspections,Simple_Counter,
                  Complex_Counter,
                  Very_Complex_Counter,Non_Motorized_Counter)
)

em_popup_tbl = leafpop::popupTable(
  em_lake |> 
    sf::st_drop_geometry() |> 
    dplyr::select(WATERSH,GNIS_NA,TotalInspections,Simple_Counter,
                  Complex_Counter,
                  Very_Complex_Counter,Non_Motorized_Counter)
)

all_wd_sus_sp = c(wd_sus |> 
  lapply(\(x) names(x)) |> 
  unlist())

all_groups_for_overlay = unique(c('highways','key fishing waterbodies','probability_raster',all_wd_sus_sp))

library(pals)

# wd_sus_sp_pal = leaflet::colorNumeric(pals::alphabet(),
#                       domain = 1:length(all_wd_sus_sp),
#                       na.color = 'transparent')
wd_sus_sp_pal = leaflet::colorFactor(pals::alphabet(),
                      domain = all_wd_sus_sp,
                      na.color = 'transparent')

# # Filter wd_sus for fraser/columbia area
# fras = sf::read_sf("W:/CMadsen/shared_data_sets/Fraser_River_Big_Watershed.shp")
# columbia = sf::read_sf("W:/CMadsen/shared_data_sets/Columbia_River_Big_Watershed.shp")
# fras_col = dplyr::bind_rows(fras, columbia) |> 
#   dplyr::summarise() |> 
#   sf::st_transform(4326)
# 
# wd_sus_fras_col = wd_sus |> 
#   sf::st_intersection(fras_col)

# # Whirling disease susceptible fish species - point data
# wd_sp_points = wd_sus_fras_col |> dplyr::filter(sf::st_geometry_type(geom) == "POINT")
# wd_sp_multip = wd_sus_fras_col |> dplyr::filter(sf::st_geometry_type(geom) == "MULTIPOLYGON")

# wd_sp_pal = leaflet::colorFactor(palette = "Set2", domain = unique(wd_sus_fras_col$Species))

l = leaflet::leaflet() |> 
  leaflet::addTiles(group = 'openstreetmap') |>
  leaflet::addProviderTiles(provider = leaflet::providers$CartoDB, group = 'carto') |> 
  addMapPane(name = 'raster_pane', zIndex = 250) |> 
  addMapPane(name = 'highway_pane', zIndex = 400) |> 
  addMapPane(name = 'dest_waterbodies', zIndex = 450) |> 
  addMapPane(name = 'wd_species', zIndex = 500) 


for(i in 1:length(wd_sus)){
  
  l = l |>
  # l |>
    # leaflet::addRasterImage(
    #   colors = wd_sus_sp_pal,
    #   x = wd_sus[i],
    #   group = names(wd_sus[i]),
    #   opacity = 0.75,
    #   options = pathOptions(pane = 'wd_species')
    # )
    leaflet::addRasterImage(
      colors = wd_sus_sp_pal(names(wd_sus[i])),
      x = wd_sus[i],
      group = names(wd_sus[i]),
      opacity = 0.75,
      options = pathOptions(pane = 'wd_species')
    ) |> 
    leaflet::hideGroup(names(wd_sus[i]))
}


l |> leaflet::addPolygons(
    data = ws,
    color = 'grey',
    fillColor = 'transparent'
  ) |> 
  leaflet::addPolylines(
    data = major_highways,
    color = 'pink',
    opacity = 1,
    group = 'highways',
    options = pathOptions(pane = "highway_pane")
  ) |> 
  leaflet::addPolygons(
    data = sf::st_transform(em_lake, 4326),
    fillColor = 'purple',
    color = 'purple',
    label = 'Emerald Lake',
    popup = lapply(em_popup_tbl, shiny::HTML)
  ) |> 
  leaflet::addPolygons(
    data = over_1000,
    label = ~GNIS_NA,
    popup = lapply(popup_tbls, shiny::HTML),
    fillColor = ~my_pal(TotalInspections),
    color = ~my_pal(TotalInspections),
    opacity = 0.75,
    fillOpacity = 0.75,
    options = pathOptions(pane = "dest_waterbodies")
  ) |> 
  leaflet::addPolylines(
    data = fishing_wbs[st_geometry_type(fishing_wbs$geometry) %in% c('LINESTRING','MULTILINESTRING'),],
    color = 'purple',
    opacity = 1,
    label = ~paste0(wb_name,"(key fishing lake/river)"),
    group = 'key fishing waterbodies'
  ) |> 
  leaflet::addPolygons(
    data = fishing_wbs[st_geometry_type(fishing_wbs$geometry) %in% c('POLYGON','MULTIPOLYON'),],
    color = 'purple',
    opacity = 1,
    fillColor = 'transparent',
    label = ~paste0(wb_name,"(key fishing lake/river)"),
    group = 'key_fishing_waterbodies'
  ) |> 
  leaflet::addPolylines(
    data = salmon_fishing_rivers,
    color = 'brown',
    opacity = 1,
    fillColor = 'transparent',
    label = ~paste0(wb_name,"(key salmon fishing river)"),
    group = 'key fishing waterbodies'
  ) |> 
  leaflet::addRasterImage(
    colors = raster_pal,
    x = tub_prob_w_carbon,
    group = 'probability_raster',
    opacity = 0.5,
    options = pathOptions(pane = 'raster_pane')
    ) |> 
  # leaflet::addCircleMarkers(
  #   data = wd_sp_points,
  #   color = ~wd_sp_pal(Species),
  #   group = "WD susceptible sp.",
  #   options = pathOptions(pane = "wd_species")
  # ) |> 
  #  leaflet::addPolygons(
  #   data = wd_sp_multip,
  #   color = 'black',
  #   weight = 1,
  #   fillColor = ~wd_sp_pal(Species),
  #   group = "WD susceptible sp.",
  #   options = pathOptions(pane = "wd_species")
  # ) |> 
  leaflet::addLegend(
    title = "<em>T. tubifex</em><br>predicted<br> density<br>",
    pal = raster_pal_legend,
    values = unique(terra::values(tub_prob_w_carbon)),
    group = 'probability_raster',
    labFormat = labelFormat(transform = function(x) sort(x, decreasing = TRUE))) |> 
  leaflet::addLegend(
    title = "Number of Inspections",
    pal = my_pal,
    values = over_1000$TotalInspections
  ) |> 
  leaflet::addLegend(
    title = "Whirling Disease<br>Susceptible Sp.",
    position = 'topleft',
    pal = wd_sus_sp_pal,
    # values = 1:length(all_wd_sus_sp)
    values = all_wd_sus_sp
  ) |> 
  leaflet::addScaleBar(position = 'bottomright') |> 
  leaflet.extras::addResetMapButton() |> 
  leaflet::addLayersControl(position = 'bottomleft',
                            baseGroups = c('carto','openstreetmap'),
                            overlayGroups = all_groups_for_overlay,
                            options = leaflet::layersControlOptions(collapsed = T))

```

#### Whirling Disease Source Locations

```{r}
if(!file.exists('../data/pascale/whirling_disease_infected_areas.gpkg')){
  library(tigris)
  library(canadianmaps)
  # Get ALL states and provinces/territories.
  usa = tigris::states(cb = TRUE)
  canada = canadianmaps::PROV |> sf::st_transform(4269)
  
  # Clip away parts of the US that are not continental / far bits of Alaska.
  canada_clipper = sf::st_bbox(canada)
  canada_clipper[1] <- -180
  canada_clipper[2] <- 0
  canada_clipper = sf::st_as_sfc(canada_clipper)
  
  usa_c = sf::st_intersection(
    usa,#|> sf::st_transform(4326),
    canada_clipper #|> sf::st_transform(4269)
  )
  
  # Filter for just those WD-infected states / provinces / territories.
  usa_wd = usa_c |> 
    dplyr::filter(STUSPS %in% c("WA","OR","CA","NV","ID","MT","WY","CO","UT","AZ","NM","NE",
                                "MI","OH","WV","VA","NC","PA","NY","VT","NH","MA","RI","CT","NJ","DE","MC","DC",
                                "AB")) |> 
    dplyr::select(name = STUSPS)
  
  canada_wd = canada |> 
    dplyr::filter(PT %in% c("WA","OR","CA","NV","ID","MT","WY","CO","UT","AZ","NM","NE",
                            "MI","OH","WV","VA","NC","PA","NY","VT","NH","MA","RI","CT","NJ","DE","MC","DC",
                            "AB")) |> 
    dplyr::select(name = PT)
  
  wd = dplyr::bind_rows(usa_wd, canada_wd) |> 
    dplyr::mutate(status = 'Whirling Disease Present')
  
  sf::write_sf(usa_c, '../data/pascale/USA_clipped.gpkg')
  sf::write_sf(canada, '../data/pascale/canada.gpkg')
  sf::write_sf(wd, '../data/pascale/whirling_disease_infected_areas.gpkg')
} else {
  usa_c = sf::read_sf('../data/pascale/USA_clipped.gpkg')
  canada = sf::read_sf('../data/pascale/canada.gpkg')
  wd = sf::read_sf('../data/pascale/whirling_disease_infected_areas.gpkg')
}

ggplot() +
  geom_sf(data = usa_c) + 
  geom_sf(data = canada) + 
  geom_sf(data = wd, aes(fill = status)) +
  scale_fill_manual(values = c('Whirling Disease Present' = 'purple')) +
  ggthemes::theme_map() + 
  theme(legend.position.inside = c(0,0.25)) + 
  ggspatial::annotation_scale() + 
  labs(fill = 'Source Area')
```

```{r}
# Things to add:
# 1. Les autoroutes plus grandes pour donner une idee que la proximite.
# 2. Highlight lakes / rivers for fishing:
# Sheridan Lake
# Chilliwack River/Vedder River
# Vedder Canal
# Fraser Rover
# Shuswap Lake
# Thompson-Nicola had the highest fishing activity in 2022
```

